// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@openzeppelin/contracts/token/ERC721/IERC721.sol';
import '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';
import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '../Proposal.sol';
import '../pool/DaoPool.sol';

abstract contract Dao is ReentrancyGuard, IERC721Receiver {

    mapping(bytes => Proposal) public proposals;
    uint256 public tokenCollateral;
    uint256 public challengePeriodSeconds;
    uint256 public nativeCollateral;
    uint256 public extendChallengePeriodSeconds;

    event ProposalCreated(
        bytes proposalId,
        address proposalAddress,
        bytes32 _proposalMerkleRootHex,
        address payable _sequencerAddress,
        uint256 _nativeCollateral,
        uint256 _tokenCollateral,
        uint256 _challengePeriodSeconds,
        bytes[] _payloads,
        uint256 _extendChallengePeriodSeconds);
    event DaoPoolCreated(address daoPoolAddress);
    function getDaoPool() internal virtual returns (DaoPool);

    // _tokenCollateral - should already include decimals
    // _challengePeriod - in seconds
    // _nativeCollateral - in wei
    constructor(uint256 _tokenCollateral, uint256 _challengePeriodSeconds, uint256 _nativeCollateral, uint256 _extendChallengePeriodSeconds) {
        tokenCollateral = _tokenCollateral;
        challengePeriodSeconds = _challengePeriodSeconds;
        nativeCollateral = _nativeCollateral;
        extendChallengePeriodSeconds = _extendChallengePeriodSeconds;
    }

    // proposalId - IPFS hash of the proposal result generated by stateborn.org
    function createProposal(bytes memory _proposalId, bytes32 _proposalMerkleRoot, bytes[] calldata _payloads) public payable nonReentrant {
        Proposal existingPool = proposals[_proposalId];
        require(address(existingPool) == address(0), 'Proposal already exists');
        Proposal proposal = new Proposal{value: msg.value}(
            _proposalMerkleRoot,
            payable(msg.sender),
            nativeCollateral,
            tokenCollateral,
            challengePeriodSeconds,
            _payloads,
            address(getDaoPool()),
            extendChallengePeriodSeconds
        );
        proposals[_proposalId] = proposal;
        getDaoPool().approveProposal(address(proposal));
        emit ProposalCreated(_proposalId, address(proposal), _proposalMerkleRoot, payable(msg.sender), nativeCollateral, tokenCollateral, challengePeriodSeconds, _payloads, extendChallengePeriodSeconds);
    }

    function sendErc20(bytes memory proposalId, address tokenAddress, address to, uint256 amount) external {
        verifyProposal(proposalId);
        require(IERC20(tokenAddress).transfer(to, amount), 'ERC20 transfer failed');
    }

    function sendNft(bytes memory proposalId, address tokenAddress, address to, uint256 tokenId) external {
        verifyProposal(proposalId);
        IERC721(tokenAddress).safeTransferFrom(address(this), to, tokenId);
    }

    function sendCrypto(bytes memory proposalId, address to, uint256 amount) external {
        require(to != address(0), 'Invalid address');
        verifyProposal(proposalId);
        payable(to).transfer(amount);
    }

    function updateTokenCollateral(bytes memory proposalId, uint256 _tokenCollateral) external {
        verifyProposal(proposalId);
        tokenCollateral = _tokenCollateral;
    }

    function updateChallengePeriodSeconds(bytes memory proposalId, uint256 _challengePeriodSeconds) external {
        verifyProposal(proposalId);
        challengePeriodSeconds = _challengePeriodSeconds;
    }

    function updateNativeCollateral(bytes memory proposalId, uint256 _nativeCollateral) external {
        verifyProposal(proposalId);
        nativeCollateral = _nativeCollateral;
    }

    function verifyProposal(bytes memory proposalId) view private {
        address proposalAddress = address(proposals[proposalId]);
        require(proposalAddress != address(0), 'Proposal does not exist');
        require(msg.sender == proposalAddress, 'Only proposal can call');
    }

    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data) external override returns (bytes4) {
        return this.onERC721Received.selector;
    }

    receive() external payable {}
}
